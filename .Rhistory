post.prob <- Estep(data, G, para)
para <- Mstep(data, G, post.prob)
}
return(para)
}
myEM(data=faithful, itmax=10, G=2, para=para0)
Estep <- function(data, G, para){
# Your Code
# Return the n-by-G probability matrix
# Sinv = solve(para$Sigma)
# nG = matrix(0,nrow = nrow(data),2)
#
# mu1 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,1], x[2] - para$mean[2,1]))), 1, function(x) 0.5*t(as.matrix(x))%*%Sinv%*%x)
# mu2 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,2], x[2] - para$mean[2,2]))), 1, function(x) -0.5*t(as.matrix(x))%*%Sinv%*%x)
#
# P1 = 1/(1 + exp(log(para$prob[2]/para$prob[1]) + mu1 + mu2))
#
# nG = cbind(P1 = P1, P2 = 1 - P1)
# return(nG)
dmnorm <- function(x, mean=rep(0,d), varcov, log=FALSE)
{
d <- if(is.matrix(varcov)) ncol(varcov) else 1
if(d==1) return(dnorm(x, mean, sqrt(varcov), log=log))
x <- if (is.vector(x)) t(matrix(x)) else data.matrix(x)
if(ncol(x) != d) stop("mismatch of dimensions of 'x' and 'varcov'")
if(is.matrix(mean)) { if ((nrow(x) != nrow(mean)) || (ncol(mean) != d))
stop("mismatch of dimensions of 'x' and 'mean'") }
if(is.vector(mean)) mean <- outer(rep(1, nrow(x)), as.vector(matrix(mean,d)))
X  <- t(x - mean)
conc <- pd.solve(varcov, log.det=TRUE)
Q <- colSums((conc %*% X)* X)
log.det <- attr(conc, "log.det")
logPDF <- as.vector(Q + d*logb(2*pi) + log.det)/(-2)
if(log) logPDF else exp(logPDF)
}
pd.solve <- function(x, silent=FALSE, log.det=FALSE)
{
if(is.null(x)) return(NULL)
if(any(is.na(x)))
{if(silent) return (NULL) else stop("NA's in x") }
if(length(x) == 1) x <- as.matrix(x)
if(!(inherits(x, "matrix")))
{if(silent) return(NULL) else stop("x is not a matrix")}
if(max(abs(x - t(x))) > .Machine$double.eps)
{if(silent) return (NULL) else stop("x appears to be not symmetric") }
x <- (x + t(x))/2
u <- try(chol(x, pivot = FALSE), silent = silent)
if(inherits(u, "try-error")) {
if(silent) return(NULL) else
stop("x appears to be not positive definite") }
inv <- chol2inv(u)
if(log.det) attr(inv, "log.det") <- 2 * sum(log(diag(u)))
dimnames(inv) <- rev(dimnames(x))
return(inv)
}
Sigma = para$Sigma
mu1 = para$mean[,1]
mu2 = para$mean[,2]
nG = matrix(0,nrow = nrow(data),2)
P_i1 = para$prob[1]*dmnorm(data,mean = mu1,Sigma, log=FALSE)/(para$prob[1]*dmnorm(data,mean = mu1,Sigma,log=FALSE)+para$prob[2]*dmnorm(data,mean = mu2,Sigma,log=FALSE))
P_i2 = para$prob[2]*dmnorm(data,mean = mu2,Sigma,log=FALSE)/(para$prob[1]*dmnorm(data,mean = mu1,Sigma,log=FALSE)+para$prob[2]*dmnorm(data,mean = mu2,Sigma,log=FALSE))
nG = cbind(P_i1, P_i2)
nG
}
Mstep <- function(data, G, post.prob){
# Your Code
# Return the updated parameters
new_p = colMeans(post.prob)
data = as.matrix(data)
A = 1/sum(post.prob[,1])*colSums(post.prob[,1]*data)
B = 1/sum(post.prob[,2])*colSums(post.prob[,2]*data)
new_mean = cbind(A,B)
C = t(post.prob[,1]* t(t(data) - new_mean[,1]))%*%t(t(data) - new_mean[,1])*1/sum(post.prob)
D = t(post.prob[,2]* t(t(data) - new_mean[,2]))%*%t(t(data) - new_mean[,2])*1/sum(post.prob)
new_sigma = C + D
new_para = list(prob = new_p, mean = new_mean,Sigma = new_sigma)
new_para
}
myEM <- function(data, itmax, G, para){
# itmax: num of iterations
# G:     num of components
# para:  list of parameters (prob, mean, Sigma)
for(t in 1:itmax){
post.prob <- Estep(data, G, para)
para <- Mstep(data, G, post.prob)
}
return(para)
}
myEM(data=faithful, itmax=10, G=2, para=para0)
Estep <- function(data, G, para){
# Your Code
# Return the n-by-G probability matrix
Sinv = solve(para$Sigma)
nG = matrix(0,nrow = nrow(data),2)
mu1 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,1], x[2] - para$mean[2,1]))), 1, function(x) 0.5*t(as.matrix(x))%*%Sinv%*%x)
mu2 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,2], x[2] - para$mean[2,2]))), 1, function(x) -0.5*t(as.matrix(x))%*%Sinv%*%x)
P1 = 1/(1 + exp(log(para$prob[2]/para$prob[1]) + mu1 + mu2))
nG = cbind(P1 = P1, P2 = 1 - P1)
return(nG)
}
Mstep <- function(data, G, post.prob){
# Your Code
# Return the updated parameters
new_p = colMeans(post.prob)
data = as.matrix(data)
mu1_new = colSums(post.prob[,1]*data)/sum(post.prob[,1])
mu2_new = colSums(post.prob[,2]*data)/sum(post.prob[,2])
new_mean = cbind(mu1_new,mu2_new)
new_sigma = t(post.prob[,1]* t(t(data) - new_mean[,1]))%*%t(t(data) - new_mean[,1])*1/sum(post.prob) + t(post.prob[,2]* t(t(data) - new_mean[,2]))%*%t(t(data) - new_mean[,2])*1/sum(post.prob)
new_para = list(prob = new_p, mean = new_mean,Sigma = new_sigma)
new_para
}
myEM <- function(data, itmax, G, para){
# itmax: num of iterations
# G:     num of components
# para:  list of parameters (prob, mean, Sigma)
for(t in 1:itmax){
post.prob <- Estep(data, G, para)
para <- Mstep(data, G, post.prob)
}
return(para)
}
myEM(data=faithful, itmax=10, G=2, para=para0)
Estep <- function(data, G, para){
# Your Code
# Return the n-by-G probability matrix
mu = para$mean
prob = para$prob
r = matrix(0,nrow = nrow(data),2)
sigma_inv = solve(para$Sigma)
Sinv = as.matrix(sigma_inv)
for (j in 1:nrow(data)){
for (k in 1:G){
r[j,k] = exp(-0.5*(as.matrix(data[j,] - mu[,k]) %*% Sinv %*% as.matrix(t(data[j,] - mu[,k]))))
}
}
r = r%*%diag(prob)/nrow(data)
r
}
Mstep <- function(data, G, para, post.prob){
# Your Code
# Return the updated parameters
new_p = colMeans(post.prob)
data = as.matrix(data)
A = 1/sum(post.prob[,1])*colSums(post.prob[,1]*data)
B = 1/sum(post.prob[,2])*colSums(post.prob[,2]*data)
new_mean = cbind(A,B)
C = t(post.prob[,1]* t(t(data) - new_mean[,1]))%*%t(t(data) - new_mean[,1])*1/sum(post.prob)
D = t(post.prob[,2]* t(t(data) - new_mean[,2]))%*%t(t(data) - new_mean[,2])*1/sum(post.prob)
new_sigma = C + D
new_para = list(prob = new_p, mean = new_mean,Sigma = new_sigma)
new_para
}
myEM <- function(data, itmax, G, para){
# itmax: num of iterations
# G:     num of components
# para:  list of parameters (prob, mean, Sigma)
for(t in 1:itmax){
post.prob <- Estep(data, G, para)
para <- Mstep(data, G, para, post.prob)
}
return(para)
}
library(mclust)
dim(faithful)
head(faithful)
n <- nrow(faithful)
set.seed(4726)
Z <- matrix(0, n, 2)
Z[sample(1:n, 120), 1] <- 1
Z[, 2] <- 1 - Z[, 1]
ini0 <- mstep(modelName="EEE", faithful , Z)$parameters
para0 <- list(prob = ini0$pro,
mean = ini0$mean,
Sigma = ini0$variance$Sigma)
para0
myEM(data=faithful, itmax=10, G=2, para=para0)
Rout <- em(modelName = "EEE", data = faithful,
control = emControl(eps=0, tol=0, itmax = 10),
parameters = ini0)$parameters
list(Rout$pro, Rout$mean, Rout$variance$Sigma)
knitr::opts_chunk$set(echo = TRUE)
mypackages = c("mclust")   # required packages
tmp = setdiff(mypackages, rownames(installed.packages()))  # packages need to be installed
if (length(tmp) > 0) install.packages(tmp)
lapply(mypackages, require, character.only = TRUE)
Estep <- function(data, G, para){
# Your Code
# Return the n-by-G probability matrix
Sinv = solve(para$Sigma)
nG = matrix(0,nrow = nrow(data),2)
t1 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,1], x[2] - para$mean[2,1]))), 1, function(x) -0.5*t(as.matrix(x))%*%Sinv%*%x)
t2 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,2], x[2] - para$mean[2,2]))), 1, function(x) -0.5*t(as.matrix(x))%*%Sinv%*%x)
P_i1 = 1/(1 + exp(log(para$prob[2]/para$prob[1]) + t1 + t2))
nG = cbind(P1 = P_i1, P2 = 1 - P_i1)
return(nG)
}
Mstep <- function(data, G, post.prob){
# Your Code
# Return the updated parameters
new_p = colMeans(post.prob)
data = as.matrix(data)
mu1_new = colSums(post.prob[,1]*data)/sum(post.prob[,1])
mu2_new = colSums(post.prob[,2]*data)/sum(post.prob[,2])
new_mean = cbind(mu1_new,mu2_new)
new_sigma = t(post.prob[,1]* t(t(data) - new_mean[,1]))%*%t(t(data) - new_mean[,1])*1/sum(post.prob) + t(post.prob[,2]* t(t(data) - new_mean[,2]))%*%t(t(data) - new_mean[,2])*1/sum(post.prob)
new_para = list(prob = new_p, mean = new_mean,Sigma = new_sigma)
new_para
}
myEM <- function(data, itmax, G, para){
# itmax: num of iterations
# G:     num of components
# para:  list of parameters (prob, mean, Sigma)
for(t in 1:itmax){
post.prob <- Estep(data, G, para)
para <- Mstep(data, G, post.prob)
}
return(para)
}
library(mclust)
dim(faithful)
head(faithful)
n <- nrow(faithful)
set.seed(4726)
Z <- matrix(0, n, 2)
Z[sample(1:n, 120), 1] <- 1
Z[, 2] <- 1 - Z[, 1]
ini0 <- mstep(modelName="EEE", faithful , Z)$parameters
para0 <- list(prob = ini0$pro,
mean = ini0$mean,
Sigma = ini0$variance$Sigma)
para0
myEM(data=faithful, itmax=10, G=2, para=para0)
Rout <- em(modelName = "EEE", data = faithful,
control = emControl(eps=0, tol=0, itmax = 10),
parameters = ini0)$parameters
list(Rout$pro, Rout$mean, Rout$variance$Sigma)
knitr::opts_chunk$set(echo = TRUE)
mypackages = c("mclust")   # required packages
tmp = setdiff(mypackages, rownames(installed.packages()))  # packages need to be installed
if (length(tmp) > 0) install.packages(tmp)
lapply(mypackages, require, character.only = TRUE)
Estep <- function(data, G, para){
# Your Code
# Return the n-by-G probability matrix
Sinv = solve(para$Sigma)
nG = matrix(0,nrow = nrow(data),2)
t1 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,1], x[2] - para$mean[2,1]))), 1, function(x) 0.5*t(as.matrix(x))%*%Sinv%*%x)
t2 = apply(t(apply(data,1, function(x) c(x[1] - para$mean[1,2], x[2] - para$mean[2,2]))), 1, function(x) -0.5*t(as.matrix(x))%*%Sinv%*%x)
P_i1 = 1 + exp(log(para$prob[2]/para$prob[1]) + t1 + t2)
P_i1 = 1/P_i1
nG = cbind(P1 = P_i1, P2 = 1 - P_i1)
return(nG)
}
Mstep <- function(data, G, post.prob){
# Your Code
# Return the updated parameters
new_p = colMeans(post.prob)
data = as.matrix(data)
mu1_new = colSums(post.prob[,1]*data)/sum(post.prob[,1])
mu2_new = colSums(post.prob[,2]*data)/sum(post.prob[,2])
new_mean = cbind(mu1_new,mu2_new)
new_sigma = t(post.prob[,1]* t(t(data) - new_mean[,1]))%*%t(t(data) - new_mean[,1])*1/sum(post.prob) + t(post.prob[,2]* t(t(data) - new_mean[,2]))%*%t(t(data) - new_mean[,2])*1/sum(post.prob)
new_para = list(prob = new_p, mean = new_mean,Sigma = new_sigma)
new_para
}
myEM <- function(data, itmax, G, para){
# itmax: num of iterations
# G:     num of components
# para:  list of parameters (prob, mean, Sigma)
for(t in 1:itmax){
post.prob <- Estep(data, G, para)
para <- Mstep(data, G, post.prob)
}
return(para)
}
library(mclust)
dim(faithful)
head(faithful)
n <- nrow(faithful)
set.seed(4726)
Z <- matrix(0, n, 2)
Z[sample(1:n, 120), 1] <- 1
Z[, 2] <- 1 - Z[, 1]
ini0 <- mstep(modelName="EEE", faithful , Z)$parameters
para0 <- list(prob = ini0$pro,
mean = ini0$mean,
Sigma = ini0$variance$Sigma)
para0
myEM(data=faithful, itmax=10, G=2, para=para0)
Rout <- em(modelName = "EEE", data = faithful,
control = emControl(eps=0, tol=0, itmax = 10),
parameters = ini0)$parameters
list(Rout$pro, Rout$mean, Rout$variance$Sigma)
?glmnet
library(glmnet)
?glmnet
install.packages("devtools")
devtools::install_github("stefanwilhelm/ShinyRatingInput")
2
devtools::install_github("stefanwilhelm/ShinyRatingInput")
remove.packages(rlang)
remove.packages("rlang")
remove.packages("rlang",lib)
rlang
?rlang
?rlang
install.packages("ShinyRatingInput")
lib
.libPaths()
remove.packages("rlang",C:/Users/i075869/Documents/R/win-library/4.0)
remove.packages("rlang","C:/Users/i075869/Documents/R/win-library/4.0")
remove.packages(rlang,"C:/Users/i075869/Documents/R/win-library/4.0")
?remove.packages
remove.packages(rlang,"C:/Users/i075869/Documents/R/win-library/4.0")
remove.packages(rlang)
setwd("C:/Users/i075869/Desktop/MS CS DS/2020/PSL 2020/Week16/srvchetry.github.io")
shiny::runApp()
new_user = 5001
myurl = "https://liangfgithub.github.io/MovieData/"
movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies,
split = "::",
fixed = TRUE,
useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
small_image_url = "https://liangfgithub.github.io/MovieImages/"
movies$image_url = sapply(movies$MovieID,
function(x)
paste0(small_image_url, x, '.jpg?raw=true'))
ratings = read.csv(
paste0(myurl, 'ratings.dat?raw=true'),
sep = ':',
colClasses = c('integer', 'NULL'),
header = FALSE
)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
ratings$Timestamp = NULL
colnames(ratings) = c('UserID', 'MovieID', 'Rating')
dimension_names <- list(UserID = sort(unique(ratings$UserID)), MovieID = sort(unique(ratings$MovieID)))
ratingmat <- spread(select(ratings, MovieID, UserID, Rating), MovieID, Rating) %>% select(-UserID)
ratingmat <- as.matrix(ratingmat)
dimnames(ratingmat) <- dimension_names
ratingmat[is.na(ratingmat)] <- 0 #### NA Handling before predictions
sparse_ratings <- as(ratingmat, "sparseMatrix")
rm(ratingmat)
gc()
real_ratings <- new("realRatingMatrix", data = sparse_ratings)
# rec = Recommender(real_ratings, method = 'IBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', k= 25))
# rec = Recommender(real_ratings, method = 'UBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', nn = 25))
# saved.recom = saveRDS(rec,"savedrecomIBCF.RDS")
# saved.recom = saveRDS(rec,"savedrecomUBCF.RDS")
# rec = readRDS("savedrecomIBCF.RDS")
rec = readRDS("savedrecomUBCF.RDS")
res = predict(rec, real_ratings[new_user,], type = 'ratings')
rec_list = as(res, 'list')
#print(sum(is.na(rec_list[[1]])))
rec_list = ifelse(is.na(rec_list[[1]]),0, rec_list[[1]])
# sort, organize, and return the results
user_results <- sort(rec_list, decreasing = TRUE)[1:10]
print(user_results)
user_predicted_ids <- as.numeric(names(user_results))
user_predicted_ids
p.movies = movies[0,]
for (i in 1:10) {
p.movies[i,] = rbind(movies[movies$MovieID == user_predicted_ids[i] ,] )
p.movies
}
print(p.movies)
recom_results <- data.table(Rank = 1:10,
MovieID = p.movies$MovieID,
Title = p.movies$Title,
Predicted_rating =  user_results)
print(recom_results)
movies$Title[recom_result$MovieID[1]]
movies$Title[recom_results$MovieID[1]]
print(p.movies)
recom_result <- data.table(Rank = 1:10,
MovieID = p.movies$MovieID,
Title = p.movies$Title,
Predicted_rating =  user_results)
print(recom_result)
movies$Title[recom_results$MovieID[1]]
movies$image_url[recom_results$MovieID[1]]
recom_result <- df_ratings()
df_ratings <- eventReactive(input$btn2, {
withBusyIndicatorServer("btn2", {
# showing the busy indicator
# hide the rating container
useShinyjs()
jsCode <-
"document.querySelector('[data-widget=collapse]').click();"
runjs(jsCode)
# get the user's rating data
value_list <- reactiveValuesToList(input)
user_ratings <- get_user_ratings(value_list)
new_user <- user_ratings$UserID
ratings <- rbind(user_ratings, ratings)
dimension_names <- list(UserID = sort(unique(ratings$UserID)), MovieID = sort(unique(ratings$MovieID)))
ratingmat <- spread(select(ratings, MovieID, UserID, Rating), MovieID, Rating) %>% select(-UserID)
ratingmat <- as.matrix(ratingmat)
dimnames(ratingmat) <- dimension_names
ratingmat[is.na(ratingmat)] <- 0 #### NA Handling before predictions
sparse_ratings <- as(ratingmat, "sparseMatrix")
rm(ratingmat)
gc()
real_ratings <- new("realRatingMatrix", data = sparse_ratings)
# run the recommender alogrithm
# rec = Recommender(real_ratings, method = 'IBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', k= 25))
# rec = Recommender(real_ratings, method = 'UBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', nn = 25))
# saved.recom = saveRDS(rec,"savedrecomIBCF.RDS")
# saved.recom = saveRDS(rec,"savedrecomUBCF.RDS")
# rec = readRDS("savedrecomIBCF.RDS")
rec = readRDS("savedrecomUBCF.RDS")
res = predict(rec, real_ratings[new_user,], type = 'ratings')
rec_list = as(res, 'list')
#print(sum(is.na(rec_list[[1]])))
rec_list = ifelse(is.na(rec_list[[1]]),0, rec_list[[1]])
# sort, organize, and return the results
user_results <- sort(rec_list, decreasing = TRUE)[1:10]
print(user_results)
user_predicted_ids <- as.numeric(names(user_results))
p.movies = movies[0,]
for (i in 1:10) {
p.movies[i,] = rbind(movies[movies$MovieID == user_predicted_ids[i] ,] )
p.movies
}
print(p.movies)
recom_result <- data.table(Rank = 1:10,
MovieID = p.movies$MovieID,
Title = p.movies$Title,
Predicted_rating =  user_results)
print(recom_result)
}) # still busy
}) # clicked on button
recom_result <- df_ratings()
runApp()
recom_result
new_user = 5001
myurl = "https://liangfgithub.github.io/MovieData/"
movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies,
split = "::",
fixed = TRUE,
useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
small_image_url = "https://liangfgithub.github.io/MovieImages/"
movies$image_url = sapply(movies$MovieID,
function(x)
paste0(small_image_url, x, '.jpg?raw=true'))
# Ratings data from
ratings = read.csv(
paste0(myurl, 'ratings.dat?raw=true'),
sep = ':',
colClasses = c('integer', 'NULL'),
header = FALSE
)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
ratings$Timestamp = NULL
colnames(ratings) = c('UserID', 'MovieID', 'Rating')
dimension_names <- list(UserID = sort(unique(ratings$UserID)), MovieID = sort(unique(ratings$MovieID)))
ratingmat <- spread(select(ratings, MovieID, UserID, Rating), MovieID, Rating) %>% select(-UserID)
ratingmat <- as.matrix(ratingmat)
dimnames(ratingmat) <- dimension_names
ratingmat[is.na(ratingmat)] <- 0 #### NA Handling before predictions
sparse_ratings <- as(ratingmat, "sparseMatrix")
rm(ratingmat)
gc()
real_ratings <- new("realRatingMatrix", data = sparse_ratings)
# run the recommender alogrithm
# rec = Recommender(real_ratings, method = 'IBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', k= 25))
# rec = Recommender(real_ratings, method = 'UBCF', parameter = list(normalize = 'Z-score', method = 'Cosine', nn = 25))
# saved.recom = saveRDS(rec,"savedrecomIBCF.RDS")
# saved.recom = saveRDS(rec,"savedrecomUBCF.RDS")
# rec = readRDS("savedrecomIBCF.RDS")
rec = readRDS("savedrecomUBCF.RDS")
res = predict(rec, real_ratings[new_user,], type = 'ratings')
rec_list = as(res, 'list')
#print(sum(is.na(rec_list[[1]])))
rec_list = ifelse(is.na(rec_list[[1]]),0, rec_list[[1]])
# sort, organize, and return the results
user_results <- sort(rec_list, decreasing = TRUE)[1:10]
#print(user_results)
user_predicted_ids <- as.numeric(names(user_results))
p.movies = movies[0,]
for (i in 1:10) {
p.movies[i,] = rbind(movies[movies$MovieID == user_predicted_ids[i] ,] )
p.movies
}
print(p.movies)
recom_result <- data.table(Rank = 1:10,
MovieID = p.movies$MovieID,
Title = p.movies$Title,
Predicted_rating =  user_results)
print(recom_result)
movies$Title[recom_result$MovieID[1]]
movies$Title[recom_result$MovieID[2]]
movies$Title[recom_result$MovieID[23]]
movies$Title[recom_result$MovieID[3]]
recom_result$MovieID
recom_result$MovieID[1]
movies$Title[recom_result$MovieID[1],]
movies$Title[movies$MovieID ==recom_result$MovieID[1]]
runApp()
